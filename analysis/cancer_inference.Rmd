---
title: "Inferring Breast Cancer Risk with Genetic Data"
author: "Julian McClellan"
date: "8/13/2020"
output: 
  revealjs::revealjs_presentation:
    theme: night
    transition: convex
---

```{r get_cohort_info, include=F}
knitr::opts_chunk$set(include=F)
# Get IDs for patients
elai.inp.geno <- c("../data/CancerChr22.geno.txt", "../data/CancerChr22.geno.txt")

extractThirdLine <- function(fp){
  require(stringr)
  
  con <- file(fp, "r")
  lines <- c()
  gotThird <- F
  
  count <- 0
  while(count != 3) {
    line <- readLines(con, 1)
    count <- count + 1
  }
  
  close(con)
  ids <- str_split(line, ", ", simplify=T)[-1] # Leave out title "IND"
  return(ids)
}

ids.chr21 <- extractThirdLine(elai.inp.geno[1])
# ids.chr22 <- extractThirdLine(elai.inp.geno[2])

# IDs should be in the same order
# all(ids.chr21 == ids.chr22) 

## Get cases

chr21.fam <- read.table("../data/CIDR_Olopade_Plus_hg19_3686subject_chr21.fam")
# chr22.fam <- read.table("../data/CIDR_Olopade_Plus_hg19_3686subject_chr22.fam")

# all(chr21.fam$V6 == chr21.fam$V6) # Cases should be same
# all(chr21.fam$V2 == chr21.fam$V2) # ==> IDs should be same
# all(chr21.fam$V2 == ids.chr21)
# all(chr21.fam$V2 == ids.chr22)

library(dplyr)
cohort <- tibble(ind = ids.chr21, case = chr21.fam$V6) %>%
  mutate(status = case_when(case == 2 ~ "cancer",
                                   case == 1 ~ "control",
                                   TRUE ~ "unknown"))
rsids.chr21 <- read.table("../output/Adm_Cancer_Chr21.snpinfo.txt", skip=2)[,1]
rsids.chr22 <- read.table("../output/Adm_Cancer_Chr22.snpinfo.txt", skip=2)[,1]
```

```{r setup_training_data, eval=F, include=F}
library(dplyr)
rsids.chr21 <- read.table("../output/Adm_Cancer_Chr21.snpinfo.txt", skip=2)[,1]
rsids.chr22 <- read.table("../output/Adm_Cancer_Chr22.snpinfo.txt", skip=2)[,1]

yy.chr21 <- scan("../output/Adm_Cancer_Chr21.ps21.txt")
S.chr21 = 2 # (source populations)
M.chr21 = 20352 # (# SNPs)
N.chr21 = 3686 # (individuals in sample)
dim(yy.chr21) <- c(S.chr21, M.chr21, N.chr21)

# Equivalent way of getting "sy" in elai example, 2 for YRI (African ancestry)
yy.chr21 <- as_tibble(t(yy.chr21[2,,]))
names(yy.chr21) <- rsids.chr21

yy.chr22 <- scan("../output/Adm_Cancer_Chr22.ps21.txt")
S.chr22 = 2 # (source populations)
M.chr22 = 21244 # (# SNPs)
N.chr22 = 3686 # (individuals in sample)
dim(yy.chr22) <- c(S.chr22, M.chr22, N.chr22)

yy.chr22 <- as_tibble(t(yy.chr22[2,,]))
names(yy.chr22) <- rsids.chr22

# Stick allele dosages for chr21 and chr22 SNPs together for 3686 cohort individuals
yy.chr2122 <- bind_cols(cohort, yy.chr21, yy.chr22)

yy.chr21 <- yy.chr21 %>%
  bind_cols(cohort, .)

yy.chr22 <- yy.chr22 %>%
  bind_cols(cohort, .)


saveRDS(yy.chr2122, "../data/for_R/chr2122.rds")
saveRDS(yy.chr21, "../data/for_R/chr21.rds")
saveRDS(yy.chr22, "../data/for_R/chr22.rds")

rm(list = ls())
```

```{r display_cohort}
library(kableExtra)

cohort_breakdown <- cohort %>%
  group_by(status) %>%
  summarize(n = n()) %>%
  rmarkdown::paged_table() %>%
  knitr::kable("html",
               digits = 5) %>%
  kable_styling(bootstrap_options = "striped",
                full_width = F, font_size = 26)

snp_breakdown <- tibble(chromosome = c(21, 22),
                        SNPs = c(length(rsids.chr21), 
                                 length(rsids.chr22))) %>% 
  rmarkdown::paged_table() %>%
  knitr::kable("html",
               digits = 5) %>%
  kable_styling(bootstrap_options = "striped",
                full_width = F, font_size = 26)
```

```{r get_panel_info}
ids.ceu <- extractThirdLine("../data/1000CEU_Chr21.geno.txt")
ids.yri <- extractThirdLine("../data/1000YRI_Chr21.geno.txt")

# ids.ceu22 <- extractThirdLine("../data/1000CEU_Chr22.geno.txt")
# ids.yri22 <- extractThirdLine("../data/1000YRI_Chr22.geno.txt")

panel_breakdown <- bind_rows(
  tibble(id = ids.ceu, ancestry = "Northern/Western Europe"),
  tibble(id = ids.yri, ancestry = "West Africa (Nigeria)")
) %>%
  group_by(ancestry) %>%
  summarize(n = n()) %>%
  rmarkdown::paged_table() %>%
  knitr::kable("html",
               digits = 5) %>%
  kable_styling(bootstrap_options = "striped",
                full_width = F, font_size = 26)
```

# Overview

<p style="text-align:left;">Using **E**fficient **L**ocal **A**ncestry **I**nference (**ELAI**) we will estimate the allele dosages for a sample of African Americans using source populations from West Africa and Northern/Western Europe.</p>

<p style="text-align:left;">Combining the ELAI results with the cancer statuses of the sample individuals, we will fit a model to infer breast cancer risk.</p>

# Data

- `r nrow(cohort)` individuals in the sample cohort 
- `r length(ids.ceu) + length(ids.yri)` individuals in the panel
  - (`r 2*(length(ids.ceu) + length(ids.yri))` haplotypes)

## Cohort

`r cohort_breakdown`

## Panel

`r panel_breakdown`

# Transformations

<p style="text-align:left;">Both the cohort files and panel files end up as bimbam format files for entry use in ELAI.</p>
 
## Sample preprocessing

![Sample preprocessing](img/preprocess_sample.png)

## Reference Preprocessing

![Reference preprocessing](img/preprocess_reference.png)

## Bimbam Processing

 - <p style="text-align:left;">For the `*geno.txt` files for the cohort and panel, the number of SNPs must be put on the 2nd row.</p>
 
![](img/bimbam_edit1.png)

## Bimbam Processing

 - <p style="text-align:left;">For the study position files the chromsome ID is added.</p>
 
![](img/bimbam_edit2.png)
 
## Bimbam Processing

 - <p style="text-align:left;">For the reference `*geno.txt` files, we add an `"="` after the number of individuals because these genotypes are *phased*, that is, we can identify which chromosome the genotypes' alleles are from.</p>

![](img/bimbam_edit3.png)

# Ancestry Inference

<p style="text-align:left;">ELAI uses a two-layer Hidden Markov model to infer local ancestry of admixed individuals.</p>

<p style="text-align:left;">Given our sample of African Americans . . .</p>

 - African Americans have 2 source populations:
    - West Africans
    - Northern/Western Europeans
 - These 2 source populations began to mix ~10 generations ago.
 
<p style="text-align:left;">These facts inform our final ELAI command.</p>
 
## ELAI Command

![ELAI Command](img/infer_ancestry.png)

## ELAI Output | Dosage

- A file containing a table with dimensions $(S, M, N)$, where:
  - $S$ corresponds to the number of source populations (`2`)
  - $M$ to the number of SNPs 
 `r snp_breakdown`
  - $N$ to the number of admixed individuals in the sample.
- For a given $s$, $m$, and $n$ in the file we will see the expected number of alleles from the $s$th source population for $m$th marker for  $n$th individual. (I.e. the allele dosage $\in[0,2]$)
  
## ELAI Output | SNP Info

- A file showing information on the SNPs.
  - `rsID`
  - `minor allele`
  - `major allele`
  - `minor allele frequency`
  - `major allele frequency`
  - `position`
  
# Cancer Risk Inference

<p style="text-align:left;">By combining elements of the ELAI input and output, we can create a file suitable for cancer risk inference, a $N \times M$ file where individual cancer statuses and rsIDs of SNPs can be identified.</p>

<br>
<br>

$$cancer\_status \sim allele\_dosage_{1} + \ \cdot\cdot\cdot \ + allele\_dosage_{M}$$

## LASSO

- LASSO has the nice property of zeroing out predictors.
- Assuming the $\lambda$ parameter can be properly adjusted this can allow a simpler model with that focuses on the most relevant SNP predictors.

## Performance

```{r display_perf}
library(readr)
models.perf <- read_rds("models.perf.rds")
models.coefplot <- read_rds("models.coefplot.rds")
model.21.coefs <- read_rds("model.21.coefs.rds")
```

# Overall Potential Adjustments

- ELAI author recommends averaging results over different mixture generation numbers. 
  - Joint model fitting: Running EM steps on source *and* admixed samples is also recommended by the author.
- Could increase # of EM runs above 30.

<br>

- Various different models, parameter tuning schemes, etc.
- Combining SNPs from multiple chromosomes, both in model training and runs of ELAI.
  - Some further adjustment of ELAI input position files would be necessary.
  
# End

```{r present_model, eval=F}
model.chr21 <- readr::read_rds("../output/model.chr21.rds") 
```


```{r toy_model}
library(readr)
library(dplyr)

train_model <- function(full_dat, trim, toy=T){
  require(caret)
  require(dplyr)
  # require(doParallel)
  # require(doMC)

  a <- seq(log(0.001), log(100), length.out = 25)
  b <- exp(a) # Left biased lambda search

  # Lasso lambda params
  hyper_grid <- expand.grid(alpha = 1, lambda = b)

  full_dat <- full_dat %>%
    filter(status != "unknown") %>%
    select(-c(ind, case))
  
  if (toy == T){
    full_dat <- full_dat[c(1:1000), c(1:100)]
  }

  if (trim == 1){ # Most trimmed/smallest model (smallest in memory)
    ctrl <- trainControl(method = "cv", # 10 folds default
                         # Save memory
                         trim = T,
                         returnData = F,
                         classProbs = T,
                         savePredictions = T,
                         summaryFunction = twoClassSummary)

  } else if (trim == 2) {
    ctrl <- trainControl(method = "cv",
                         returnData = T,
                         trim = T,
                         classProbs = T,
                         savePredictions = T,
                         summaryFunction = twoClassSummary)
  
  } else if (trim == 3) { # Fattest model (biggest in memory)
    ctrl <- trainControl(method = "cv",
                         returnData = T,
                         classProbs = T,
                         savePredictions = T,
                         summaryFunction = twoClassSummary)
  }

  options(expressions = 500000)
  # registerDoMC(2)
  # Nslots <- as.numeric(Sys.getenv("SLURM_CPUS_ON_NODE"))
  # cat(as.character(Nslots), "\n")
  # cl <- makeCluster(Nslots, outfile = "")
  #
  # registerDoParallel(cl)
  #

  set.seed(8162020)
  model <- train(status ~ .,
                 data = full_dat,
                 method = "glmnet",
                 metric = "ROC",
                 trControl = ctrl,
                 tuneGrid = hyper_grid
  )
}

train_model(read_rds("../data/for_R/chr21.rds"), 3) %>%
  write_rds("../output/model.chr21.rds")
train_model(read_rds("../data/for_R/chr22.rds"), 3) %>%
  write_rds("../output/model.chr22.rds")
train_model(read_rds("../data/for_R/chr2122.rds"), 3) %>%
  write_rds("../output/model.chr2122.rds")
```
```{r toy_present}
# model.most.skinny.21 <- read_rds("../output/model.chr21.skinny.most.rds")
# model.skinny.21 <- read_rds("../output/model.chr21.skinny.rds")
model.21 <- read_rds("../output/model.chr21.rds")
model.22 <- read_rds("../output/model.chr22.rds")
model.2122 <- read_rds("../output/model.chr2122.rds")

perf <- MLeval::evalm(list(model.21, model.22, model.2122), title = "ROC Curve Comparison", gnames=c("Chromosome 21", "Chromosome 22", "Chromosomes 21/22"), showplots = F, plots = "r", rlinethick = 1)

# save_rds(perf, "../output/performance.rds")

coefplot <- coefplot::multiplot(list(`Chromosome 21` = model.21$finalModel, `Chromosome 22` = model.22$finalModel, `Chromosome 21/22` = model.2122$finalModel),
                                pointSize = 1.75) +
  theme_minimal()
```
